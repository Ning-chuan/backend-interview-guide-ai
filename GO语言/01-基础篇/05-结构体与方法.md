# ç¬¬5ç« ï¼šç»“æ„ä½“ä¸æ–¹æ³•

## ç« èŠ‚æ¦‚è¦
æœ¬ç« æ·±å…¥æ¢è®¨Goè¯­è¨€ä¸­çš„ç»“æ„ä½“å®šä¹‰ã€æ–¹æ³•ç»‘å®šã€åµŒå…¥æœºåˆ¶ä»¥åŠé¢å‘å¯¹è±¡ç¼–ç¨‹çš„å®ç°æ–¹å¼ã€‚ä»åŸºç¡€è¯­æ³•åˆ°é«˜çº§ç‰¹æ€§ï¼Œä»å†…å­˜å¸ƒå±€åˆ°æ€§èƒ½ä¼˜åŒ–ï¼Œå…¨é¢æŒæ¡Goè¯­è¨€ç»“æ„ä½“ç¼–ç¨‹çš„ç²¾é«“ã€‚

## å­¦ä¹ ç›®æ ‡
- **åŸºç¡€æŒæ¡**ï¼šç»“æ„ä½“å®šä¹‰ã€åˆå§‹åŒ–å’ŒåŸºæœ¬æ“ä½œ
- **æ·±å…¥ç†è§£**ï¼šæ–¹æ³•çš„å®šä¹‰ã€æ¥æ”¶è€…ç±»å‹é€‰æ‹©å’Œæ–¹æ³•é›†è§„åˆ™
- **é«˜çº§åº”ç”¨**ï¼šç»“æ„ä½“åµŒå…¥ã€ç»„åˆæ¨¡å¼å’Œæ¥å£å®ç°
- **æ€§èƒ½ä¼˜åŒ–**ï¼šå†…å­˜å¸ƒå±€ã€å¯¹é½æœºåˆ¶å’Œæ€§èƒ½æœ€ä½³å®è·µ
- **å®æˆ˜æŠ€èƒ½**ï¼šæ„é€ å‡½æ•°æ¨¡å¼ã€æ ‡ç­¾åº”ç”¨å’Œåå°„æ“ä½œ
- **é¢è¯•å‡†å¤‡**ï¼šå¸¸è§é™·é˜±ã€åº•å±‚åŸç†å’Œè®¾è®¡æ¨¡å¼

## æ ¸å¿ƒçŸ¥è¯†ç‚¹å¯¼å›¾
```
ç»“æ„ä½“ä¸æ–¹æ³•
â”œâ”€â”€ ç»“æ„ä½“åŸºç¡€
â”‚   â”œâ”€â”€ å®šä¹‰è¯­æ³•ï¼ˆå‘½åå­—æ®µã€åŒ¿åå­—æ®µã€ç©ºç»“æ„ä½“ï¼‰
â”‚   â”œâ”€â”€ åˆå§‹åŒ–æ–¹å¼ï¼ˆé›¶å€¼ã€å­—é¢é‡ã€æ„é€ å‡½æ•°ï¼‰
â”‚   â”œâ”€â”€ å†…å­˜å¸ƒå±€ï¼ˆå­—æ®µå¯¹é½ã€å†…å­˜å ç”¨ï¼‰
â”‚   â””â”€â”€ è®¿é—®æ“ä½œï¼ˆå­—æ®µè®¿é—®ã€æŒ‡é’ˆæ“ä½œï¼‰
â”œâ”€â”€ æ–¹æ³•ç³»ç»Ÿ
â”‚   â”œâ”€â”€ æ–¹æ³•å®šä¹‰ï¼ˆå€¼æ¥æ”¶è€…ã€æŒ‡é’ˆæ¥æ”¶è€…ï¼‰
â”‚   â”œâ”€â”€ æ–¹æ³•é›†è§„åˆ™ï¼ˆç±»å‹æ–¹æ³•é›†ã€æ¥å£å®ç°ï¼‰
â”‚   â”œâ”€â”€ æ–¹æ³•è°ƒç”¨ï¼ˆè‡ªåŠ¨è½¬æ¢ã€æ€§èƒ½è€ƒé‡ï¼‰
â”‚   â””â”€â”€ æ–¹æ³•é‡å†™ï¼ˆåµŒå…¥ç±»å‹æ–¹æ³•è¦†ç›–ï¼‰
â”œâ”€â”€ åµŒå…¥æœºåˆ¶
â”‚   â”œâ”€â”€ åŒ¿ååµŒå…¥ï¼ˆå­—æ®µæå‡ã€æ–¹æ³•æå‡ï¼‰
â”‚   â”œâ”€â”€ ç»„åˆæ¨¡å¼ï¼ˆhas-aå…³ç³»ã€æ¥å£ç»„åˆï¼‰
â”‚   â”œâ”€â”€ å†²çªå¤„ç†ï¼ˆå­—æ®µå†²çªã€æ–¹æ³•å†²çªï¼‰
â”‚   â””â”€â”€ å¤šå±‚åµŒå…¥ï¼ˆæ·±åº¦åµŒå…¥ã€è®¿é—®è·¯å¾„ï¼‰
â”œâ”€â”€ é«˜çº§ç‰¹æ€§
â”‚   â”œâ”€â”€ ç»“æ„ä½“æ ‡ç­¾ï¼ˆJSONã€æ•°æ®åº“ã€éªŒè¯ï¼‰
â”‚   â”œâ”€â”€ æ„é€ å‡½æ•°ï¼ˆç®€å•æ„é€ ã€é€‰é¡¹æ¨¡å¼ã€å»ºé€ è€…æ¨¡å¼ï¼‰
â”‚   â”œâ”€â”€ æ¯”è¾ƒæ“ä½œï¼ˆå¯æ¯”è¾ƒæ€§ã€æ·±åº¦æ¯”è¾ƒï¼‰
â”‚   â””â”€â”€ å¤åˆ¶æœºåˆ¶ï¼ˆæµ…æ‹·è´ã€æ·±æ‹·è´ã€å¼•ç”¨å…±äº«ï¼‰
â””â”€â”€ æ€§èƒ½ä¼˜åŒ–
    â”œâ”€â”€ å†…å­˜å¯¹é½ï¼ˆå­—æ®µæ’åºã€paddingä¼˜åŒ–ï¼‰
    â”œâ”€â”€ æ¥æ”¶è€…é€‰æ‹©ï¼ˆæ€§èƒ½vsè¯­ä¹‰ã€å¤§ç»“æ„ä½“å¤„ç†ï¼‰
    â”œâ”€â”€ é›¶æ‹·è´æŠ€æœ¯ï¼ˆæŒ‡é’ˆä¼ é€’ã€æ¥å£ä¼˜åŒ–ï¼‰
    â””â”€â”€ å†…å­˜æ± åŒ–ï¼ˆå¯¹è±¡å¤ç”¨ã€GCä¼˜åŒ–ï¼‰
```

## ä¸»è¦å†…å®¹

### 5.1 ç»“æ„ä½“åŸºç¡€

#### 5.1.1 ç»“æ„ä½“å®šä¹‰è¯¦è§£

**åŸºæœ¬ç»“æ„ä½“å®šä¹‰**
```go
// æ ‡å‡†ç»“æ„ä½“å®šä¹‰
type Person struct {
    Name string  // å¯¼å‡ºå­—æ®µï¼ˆé¦–å­—æ¯å¤§å†™ï¼‰
    age  int     // æœªå¯¼å‡ºå­—æ®µï¼ˆé¦–å­—æ¯å°å†™ï¼‰
    City string
}

// å­—æ®µå¯è§æ€§è§„åˆ™
type Visibility struct {
    PublicField  string  // åŒ…å¤–å¯è®¿é—®
    privateField int     // ä»…åŒ…å†…å¯è®¿é—®
}
```

**åŒ¿åå­—æ®µç»“æ„ä½“**
```go
// åŒ¿åå­—æ®µï¼ˆåµŒå…¥ç±»å‹ï¼‰
type Employee struct {
    string    // åŒ¿åå­—æ®µï¼Œå­—æ®µåä¸ºç±»å‹å
    int       // å¤šä¸ªç›¸åŒç±»å‹éœ€è¦å‘½å
    bool
    *Person   // åµŒå…¥æŒ‡é’ˆç±»å‹
}

// è®¿é—®åŒ¿åå­—æ®µ
emp := Employee{
    string: "å¼ ä¸‰",
    int:    30,
    bool:   true,
}
fmt.Println(emp.string)  // é€šè¿‡ç±»å‹åè®¿é—®
```

**ç©ºç»“æ„ä½“çš„å¦™ç”¨**
```go
// ç©ºç»“æ„ä½“ - é›¶å†…å­˜å ç”¨
type Empty struct{}

// åº”ç”¨åœºæ™¯1ï¼šä¿¡å·é€šé“
type Signal struct{}
ch := make(chan Signal)

// åº”ç”¨åœºæ™¯2ï¼šé›†åˆå®ç°
type Set map[string]struct{}
set := make(Set)
set["key"] = struct{}{}  // æ·»åŠ å…ƒç´ 
_, exists := set["key"]  // æ£€æŸ¥å­˜åœ¨

// åº”ç”¨åœºæ™¯3ï¼šæ–¹æ³•æ¥æ”¶è€…
type Utility struct{}
func (Utility) Helper() string { return "helper" }

// éªŒè¯ç©ºç»“æ„ä½“å¤§å°
fmt.Println(unsafe.Sizeof(Empty{}))  // è¾“å‡º: 0
```

**ç»“æ„ä½“æ ‡ç­¾ç³»ç»Ÿ**
```go
// å®Œæ•´çš„æ ‡ç­¾ç¤ºä¾‹
type User struct {
    ID       int    `json:"id" db:"user_id" validate:"required"`
    Username string `json:"username" db:"username" validate:"min=3,max=20"`
    Email    string `json:"email" db:"email_address" validate:"email"`
    Password string `json:"-" db:"password" validate:"min=8"`
    Profile  *Profile `json:"profile,omitempty" db:"-"`
}

// æ ‡ç­¾è¯­æ³•è§„åˆ™
type TagExample struct {
    Field1 string `key:"value"`                    // å•ä¸ªæ ‡ç­¾
    Field2 string `key1:"value1" key2:"value2"`    // å¤šä¸ªæ ‡ç­¾
    Field3 string `json:"field3,omitempty"`        // å¸¦é€‰é¡¹çš„æ ‡ç­¾
    Field4 string `json:"-"`                       // å¿½ç•¥å­—æ®µ
    Field5 string `json:",string"`                 // ç±»å‹è½¬æ¢
}
```

**å†…å­˜å¸ƒå±€å’Œå¯¹é½**
```go
// å­—æ®µå¯¹é½ç¤ºä¾‹
type BadLayout struct {
    a bool   // 1å­—èŠ‚
    b int64  // 8å­—èŠ‚ï¼Œéœ€è¦7å­—èŠ‚padding
    c bool   // 1å­—èŠ‚
    d int64  // 8å­—èŠ‚ï¼Œéœ€è¦7å­—èŠ‚padding
}
// æ€»å¤§å°ï¼š32å­—èŠ‚ï¼ˆåŒ…å«paddingï¼‰

type GoodLayout struct {
    b int64  // 8å­—èŠ‚
    d int64  // 8å­—èŠ‚
    a bool   // 1å­—èŠ‚
    c bool   // 1å­—èŠ‚ï¼Œå…±äº«padding
}
// æ€»å¤§å°ï¼š24å­—èŠ‚

// æŸ¥çœ‹ç»“æ„ä½“å¤§å°å’Œå¯¹é½
fmt.Printf("BadLayout size: %d\n", unsafe.Sizeof(BadLayout{}))
fmt.Printf("GoodLayout size: %d\n", unsafe.Sizeof(GoodLayout{}))
```

#### 5.1.2 ç»“æ„ä½“åˆå§‹åŒ–è¯¦è§£

**é›¶å€¼åˆå§‹åŒ–æœºåˆ¶**
```go
// é›¶å€¼åˆå§‹åŒ– - Goçš„å®‰å…¨ç‰¹æ€§
var p1 Person
fmt.Printf("é›¶å€¼: %+v\n", p1)  // {Name: age:0 City:}

// å„ç±»å‹çš„é›¶å€¼
type ZeroValues struct {
    Bool    bool       // false
    Int     int        // 0
    Float   float64    // 0.0
    String  string     // ""
    Pointer *int       // nil
    Slice   []int      // nil
    Map     map[string]int // nil
    Channel chan int   // nil
    Func    func()     // nil
}

// é›¶å€¼çš„å®ç”¨æ€§
var counter struct {
    count int
    mutex sync.Mutex  // é›¶å€¼å¯ç›´æ¥ä½¿ç”¨
}
counter.mutex.Lock()  // æ— éœ€åˆå§‹åŒ–
```

**å­—é¢é‡åˆå§‹åŒ–æœ€ä½³å®è·µ**
```go
// æ¨èï¼šå‘½åå­—æ®µåˆå§‹åŒ–
p2 := Person{
    Name: "å¼ ä¸‰",
    age:  25,
    City: "åŒ—äº¬",
}

// ä¸æ¨èï¼šé¡ºåºåˆå§‹åŒ–ï¼ˆè„†å¼±ï¼Œæ˜“å‡ºé”™ï¼‰
p3 := Person{"æå››", 30, "ä¸Šæµ·"}

// éƒ¨åˆ†åˆå§‹åŒ– - å…¶ä»–å­—æ®µä½¿ç”¨é›¶å€¼
p4 := Person{
    Name: "ç‹äº”",
    age:  28,
    // Cityä½¿ç”¨é›¶å€¼""
}

// åµŒå¥—ç»“æ„ä½“åˆå§‹åŒ–
type Address struct {
    Street string
    City   string
}

type PersonWithAddr struct {
    Name    string
    Address Address
}

// æ–¹å¼1ï¼šåµŒå¥—å­—é¢é‡
p5 := PersonWithAddr{
    Name: "èµµå…­",
    Address: Address{
        Street: "ä¸­å±±è·¯123å·",
        City:   "åŒ—äº¬",
    },
}

// æ–¹å¼2ï¼šåˆ†æ­¥åˆå§‹åŒ–
p6 := PersonWithAddr{
    Name: "å­™ä¸ƒ",
}
p6.Address.Street = "äººæ°‘è·¯456å·"
p6.Address.City = "ä¸Šæµ·"
```

**æŒ‡é’ˆå’Œå†…å­˜åˆ†é…**
```go
// ä½¿ç”¨newå‡½æ•° - åˆ†é…é›¶å€¼å†…å­˜
p7 := new(Person)  // è¿”å›*Personç±»å‹
p7.Name = "èµµå…­"
p7.age = 35

// ä½¿ç”¨&æ“ä½œç¬¦ - å–åœ°å€
p8 := &Person{
    Name: "é’±å…«",
    age:  40,
    City: "æ·±åœ³",
}

// å†…å­˜åˆ†é…å¯¹æ¯”
var p9 Person        // æ ˆåˆ†é…ï¼ˆé€šå¸¸ï¼‰
p10 := new(Person)   // å †åˆ†é…
p11 := &Person{}     // å¯èƒ½æ ˆåˆ†é…æˆ–å †åˆ†é…ï¼ˆé€ƒé€¸åˆ†æå†³å®šï¼‰

// æ£€æŸ¥å†…å­˜åˆ†é…ä½ç½®ï¼ˆéœ€è¦ç¼–è¯‘æ—¶åˆ†æï¼‰
// go build -gcflags="-m" main.go
```

**æ„é€ å‡½æ•°æ¨¡å¼è¿›é˜¶**
```go
// ç®€å•æ„é€ å‡½æ•°
func NewPerson(name string, age int, city string) *Person {
    return &Person{
        Name: name,
        age:  age,
        City: city,
    }
}

// å¸¦éªŒè¯çš„æ„é€ å‡½æ•°
func NewPersonWithValidation(name string, age int, city string) (*Person, error) {
    if name == "" {
        return nil, errors.New("å§“åä¸èƒ½ä¸ºç©º")
    }
    if age < 0 || age > 150 {
        return nil, errors.New("å¹´é¾„å¿…é¡»åœ¨0-150ä¹‹é—´")
    }
    
    return &Person{
        Name: name,
        age:  age,
        City: city,
    }, nil
}

// å·¥å‚å‡½æ•°æ¨¡å¼
type PersonType int

const (
    Student PersonType = iota
    Teacher
    Worker
)

func CreatePerson(pType PersonType, name string, age int) *Person {
    p := &Person{Name: name, age: age}
    
    switch pType {
    case Student:
        p.City = "å­¦ç”ŸåŸ"
    case Teacher:
        p.City = "æ•™å¸ˆåŸ"
    case Worker:
        p.City = "å·¥äººåŸ"
    }
    
    return p
}

// ä½¿ç”¨ç¤ºä¾‹
p12 := NewPerson("å­™ä¸ƒ", 40, "æ·±åœ³")
p13, err := NewPersonWithValidation("å‘¨å…«", 25, "å¹¿å·")
if err != nil {
    log.Fatal(err)
}
p14 := CreatePerson(Student, "å´ä¹", 20)
```

#### 5.1.3 ç»“æ„ä½“æ“ä½œè¯¦è§£

**å­—æ®µè®¿é—®å’Œä¿®æ”¹**
```go
// åŸºæœ¬å­—æ®µè®¿é—®
fmt.Println(p2.Name)
p2.age = 31

// å­—æ®µå¯è§æ€§æ§åˆ¶
type Account struct {
    PublicField  string  // åŒ…å¤–å¯è®¿é—®
    privateField int     // ä»…åŒ…å†…å¯è®¿é—®
}

acc := Account{PublicField: "public"}
// acc.privateField = 10  // ç¼–è¯‘é”™è¯¯ï¼šåŒ…å¤–ä¸å¯è®¿é—®

// é€šè¿‡æ–¹æ³•è®¿é—®ç§æœ‰å­—æ®µ
func (a *Account) SetPrivateField(value int) {
    a.privateField = value
}

func (a Account) GetPrivateField() int {
    return a.privateField
}
```

**æŒ‡é’ˆæ“ä½œæ·±å…¥**
```go
// ç»“æ„ä½“æŒ‡é’ˆçš„å¤šç§åˆ›å»ºæ–¹å¼
p1 := &Person{Name: "èµµå…­", age: 28}
fmt.Println(p1.Name)    // è‡ªåŠ¨è§£å¼•ç”¨
fmt.Println((*p1).Name) // æ˜¾å¼è§£å¼•ç”¨

// æŒ‡é’ˆçš„æŒ‡é’ˆ
var pp **Person
p := &Person{Name: "å¼ ä¸‰"}
pp = &p
fmt.Println((**pp).Name)  // å¤šå±‚è§£å¼•ç”¨

// nilæŒ‡é’ˆæ£€æŸ¥
var nilPtr *Person
if nilPtr != nil {
    fmt.Println(nilPtr.Name)  // å®‰å…¨è®¿é—®
} else {
    fmt.Println("æŒ‡é’ˆä¸ºnil")
}

// æŒ‡é’ˆæ¯”è¾ƒ
p2 := &Person{Name: "æå››"}
p3 := &Person{Name: "æå››"}
fmt.Println(p2 == p3)     // falseï¼Œä¸åŒçš„å†…å­˜åœ°å€
fmt.Println(*p2 == *p3)   // trueï¼Œå€¼ç›¸ç­‰
```

**ç»“æ„ä½“èµ‹å€¼å’Œä¼ é€’**
```go
// å€¼ä¼ é€’ - åˆ›å»ºå‰¯æœ¬
func modifyByValue(p Person) {
    p.Name = "ä¿®æ”¹åçš„åå­—"  // åªä¿®æ”¹å‰¯æœ¬
}

// æŒ‡é’ˆä¼ é€’ - ä¿®æ”¹åŸå§‹å€¼
func modifyByPointer(p *Person) {
    p.Name = "ä¿®æ”¹åçš„åå­—"  // ä¿®æ”¹åŸå§‹å€¼
}

// ä½¿ç”¨ç¤ºä¾‹
original := Person{Name: "åŸå§‹åå­—", age: 25}
modifyByValue(original)
fmt.Println(original.Name)  // "åŸå§‹åå­—" - æœªæ”¹å˜

modifyByPointer(&original)
fmt.Println(original.Name)  // "ä¿®æ”¹åçš„åå­—" - å·²æ”¹å˜

// å¤§ç»“æ„ä½“çš„æ€§èƒ½è€ƒè™‘
type LargeStruct struct {
    data [1000]int
    name string
}

// å€¼ä¼ é€’ - å¤åˆ¶1000ä¸ªintï¼Œæ€§èƒ½å·®
func processLarge(ls LargeStruct) {
    // å¤„ç†é€»è¾‘
}

// æŒ‡é’ˆä¼ é€’ - åªå¤åˆ¶æŒ‡é’ˆï¼Œæ€§èƒ½å¥½
func processLargePtr(ls *LargeStruct) {
    // å¤„ç†é€»è¾‘
}
```

**ç»“æ„ä½“æ¯”è¾ƒæ“ä½œ**
```go
// å¯æ¯”è¾ƒçš„ç»“æ„ä½“
type Point struct {
    X, Y int
}

p1 := Point{1, 2}
p2 := Point{1, 2}
p3 := Point{2, 3}

fmt.Println(p1 == p2)  // true
fmt.Println(p1 == p3)  // false

// ä¸å¯æ¯”è¾ƒçš„ç»“æ„ä½“ï¼ˆåŒ…å«åˆ‡ç‰‡ã€æ˜ å°„ã€å‡½æ•°ï¼‰
type Container struct {
    Data []int     // åˆ‡ç‰‡ä¸å¯æ¯”è¾ƒ
    Meta map[string]string  // æ˜ å°„ä¸å¯æ¯”è¾ƒ
}

// è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°
func (c1 Container) Equal(c2 Container) bool {
    // æ¯”è¾ƒåˆ‡ç‰‡
    if len(c1.Data) != len(c2.Data) {
        return false
    }
    for i, v := range c1.Data {
        if v != c2.Data[i] {
            return false
        }
    }
    
    // æ¯”è¾ƒæ˜ å°„
    if len(c1.Meta) != len(c2.Meta) {
        return false
    }
    for k, v := range c1.Meta {
        if c2.Meta[k] != v {
            return false
        }
    }
    
    return true
}
```

**ç»“æ„ä½“è½¬æ¢å’Œç±»å‹æ–­è¨€**
```go
// ç»“æ„ä½“ç±»å‹è½¬æ¢
type Student struct {
    Name string
    age  int
}

type Teacher struct {
    Name string
    age  int
}

// ç›¸åŒå­—æ®µç»“æ„çš„è½¬æ¢
s := Student{Name: "å­¦ç”Ÿ", age: 20}
t := Teacher(s)  // æ˜¾å¼è½¬æ¢
fmt.Printf("%+v\n", t)

// æ¥å£ç±»å‹æ–­è¨€
var i interface{} = Person{Name: "å¼ ä¸‰", age: 25}
if p, ok := i.(Person); ok {
    fmt.Printf("è½¬æ¢æˆåŠŸ: %+v\n", p)
}

// ç±»å‹å¼€å…³
func processAny(v interface{}) {
    switch val := v.(type) {
    case Person:
        fmt.Printf("Person: %s\n", val.Name)
    case Student:
        fmt.Printf("Student: %s\n", val.Name)
    default:
        fmt.Printf("Unknown type: %T\n", val)
    }
}
```

### 5.2 æ–¹æ³•ç³»ç»Ÿæ·±å…¥

#### 5.2.1 æ–¹æ³•å®šä¹‰å’Œè¯­æ³•

**åŸºæœ¬æ–¹æ³•å®šä¹‰**
```go
// å€¼æ¥æ”¶è€…æ–¹æ³• - æ¥æ”¶ç»“æ„ä½“çš„å‰¯æœ¬
func (p Person) GetInfo() string {
    return fmt.Sprintf("å§“å: %s, å¹´é¾„: %d", p.Name, p.age)
}

// æŒ‡é’ˆæ¥æ”¶è€…æ–¹æ³• - æ¥æ”¶ç»“æ„ä½“çš„æŒ‡é’ˆ
func (p *Person) SetAge(age int) {
    p.age = age
}

// æ–¹æ³•è°ƒç”¨çš„è‡ªåŠ¨è½¬æ¢
p := Person{Name: "å¼ ä¸‰", age: 30}
info := p.GetInfo()  // å€¼æ¥æ”¶è€…ï¼Œç›´æ¥è°ƒç”¨
p.SetAge(31)         // æŒ‡é’ˆæ¥æ”¶è€…ï¼Œè‡ªåŠ¨å–åœ°å€ (&p).SetAge(31)

// æŒ‡é’ˆå˜é‡è°ƒç”¨æ–¹æ³•
ptr := &Person{Name: "æå››", age: 25}
info2 := ptr.GetInfo()  // å€¼æ¥æ”¶è€…ï¼Œè‡ªåŠ¨è§£å¼•ç”¨ (*ptr).GetInfo()
ptr.SetAge(26)          // æŒ‡é’ˆæ¥æ”¶è€…ï¼Œç›´æ¥è°ƒç”¨
```

**æ–¹æ³•çš„æœ¬è´¨ - è¯­æ³•ç³–**
```go
// æ–¹æ³•å®šä¹‰
func (p Person) GetInfo() string {
    return fmt.Sprintf("å§“å: %s", p.Name)
}

// ç­‰ä»·çš„å‡½æ•°å®šä¹‰
func PersonGetInfo(p Person) string {
    return fmt.Sprintf("å§“å: %s", p.Name)
}

// è°ƒç”¨æ–¹å¼å¯¹æ¯”
p := Person{Name: "å¼ ä¸‰"}
info1 := p.GetInfo()           // æ–¹æ³•è°ƒç”¨
info2 := PersonGetInfo(p)      // å‡½æ•°è°ƒç”¨
```

**æ–¹æ³•å‘½åå’Œç»„ç»‡**
```go
type BankAccount struct {
    balance float64
    owner   string
}

// æŸ¥è¯¢ç±»æ–¹æ³• - é€šå¸¸ä½¿ç”¨å€¼æ¥æ”¶è€…
func (ba BankAccount) GetBalance() float64 {
    return ba.balance
}

func (ba BankAccount) GetOwner() string {
    return ba.owner
}

// ä¿®æ”¹ç±»æ–¹æ³• - é€šå¸¸ä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…
func (ba *BankAccount) Deposit(amount float64) error {
    if amount <= 0 {
        return errors.New("å­˜æ¬¾é‡‘é¢å¿…é¡»å¤§äº0")
    }
    ba.balance += amount
    return nil
}

func (ba *BankAccount) Withdraw(amount float64) error {
    if amount <= 0 {
        return errors.New("å–æ¬¾é‡‘é¢å¿…é¡»å¤§äº0")
    }
    if amount > ba.balance {
        return errors.New("ä½™é¢ä¸è¶³")
    }
    ba.balance -= amount
    return nil
}

// é“¾å¼è°ƒç”¨æ–¹æ³•
func (ba *BankAccount) SetOwner(owner string) *BankAccount {
    ba.owner = owner
    return ba
}

func (ba *BankAccount) AddBalance(amount float64) *BankAccount {
    ba.balance += amount
    return ba
}

// ä½¿ç”¨é“¾å¼è°ƒç”¨
account := &BankAccount{}
account.SetOwner("å¼ ä¸‰").AddBalance(1000)
```

#### 5.2.2 å€¼æ¥æ”¶è€… vs æŒ‡é’ˆæ¥æ”¶è€…è¯¦è§£

**åŸºæœ¬åŒºåˆ«å’Œè¡Œä¸º**
```go
type Counter struct {
    count int
    name  string
}

// å€¼æ¥æ”¶è€… - æ“ä½œå‰¯æœ¬ï¼Œä¸å½±å“åŸå§‹å€¼
func (c Counter) Increment() {
    c.count++  // åªä¿®æ”¹å‰¯æœ¬
    fmt.Printf("å€¼æ¥æ”¶è€…å†…éƒ¨: %d\n", c.count)
}

// æŒ‡é’ˆæ¥æ”¶è€… - æ“ä½œåŸå§‹å€¼
func (c *Counter) IncrementPtr() {
    c.count++  // ä¿®æ”¹åŸå§‹å€¼
    fmt.Printf("æŒ‡é’ˆæ¥æ”¶è€…å†…éƒ¨: %d\n", c.count)
}

// å€¼æ¥æ”¶è€… - è¯»å–æ“ä½œ
func (c Counter) GetCount() int {
    return c.count
}

// æŒ‡é’ˆæ¥æ”¶è€… - è¯»å–æ“ä½œï¼ˆé¿å…å¤§ç»“æ„ä½“å¤åˆ¶ï¼‰
func (c *Counter) GetCountPtr() int {
    return c.count
}

// ä½¿ç”¨ç¤ºä¾‹
c := Counter{count: 0, name: "è®¡æ•°å™¨"}
fmt.Printf("åˆå§‹å€¼: %d\n", c.count)

c.Increment()    // countä»ä¸º0
fmt.Printf("å€¼æ¥æ”¶è€…å: %d\n", c.count)

c.IncrementPtr() // countå˜ä¸º1
fmt.Printf("æŒ‡é’ˆæ¥æ”¶è€…å: %d\n", c.count)
```

**é€‰æ‹©æ¥æ”¶è€…ç±»å‹çš„åŸåˆ™**
```go
// 1. éœ€è¦ä¿®æ”¹æ¥æ”¶è€… -> ä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…
type Account struct {
    balance float64
}

func (a *Account) Deposit(amount float64) {
    a.balance += amount  // å¿…é¡»ä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…
}

// 2. å¤§ç»“æ„ä½“ -> ä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…é¿å…å¤åˆ¶
type LargeStruct struct {
    data [1000]int
    meta map[string]string
}

func (ls *LargeStruct) Process() {
    // é¿å…å¤åˆ¶1000ä¸ªint
}

// 3. ä¸€è‡´æ€§åŸåˆ™ - å¦‚æœæœ‰æŒ‡é’ˆæ¥æ”¶è€…æ–¹æ³•ï¼Œå…¶ä»–æ–¹æ³•ä¹Ÿåº”è¯¥ä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…
type User struct {
    name  string
    email string
}

func (u *User) SetName(name string) {
    u.name = name
}

// ä¸ºäº†ä¸€è‡´æ€§ï¼Œè¯»å–æ–¹æ³•ä¹Ÿä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…
func (u *User) GetName() string {
    return u.name
}

// 4. å°çš„å€¼ç±»å‹ä¸”ä¸éœ€è¦ä¿®æ”¹ -> ä½¿ç”¨å€¼æ¥æ”¶è€…
type Point struct {
    X, Y int
}

func (p Point) Distance() float64 {
    return math.Sqrt(float64(p.X*p.X + p.Y*p.Y))
}

// 5. å®ç°æ¥å£æ—¶çš„è€ƒè™‘
type Stringer interface {
    String() string
}

// å€¼æ¥æ”¶è€…å®ç°æ¥å£
func (p Point) String() string {
    return fmt.Sprintf("(%d, %d)", p.X, p.Y)
}

// æŒ‡é’ˆæ¥æ”¶è€…å®ç°æ¥å£
func (u *User) String() string {
    return fmt.Sprintf("User: %s <%s>", u.name, u.email)
}
```

**æ€§èƒ½å¯¹æ¯”åˆ†æ**
```go
// æ€§èƒ½æµ‹è¯•ç»“æ„ä½“
type PerformanceTest struct {
    data [100]int
    name string
}

// å€¼æ¥æ”¶è€… - æ¯æ¬¡è°ƒç”¨å¤åˆ¶400å­—èŠ‚
func (pt PerformanceTest) ProcessByValue() int {
    sum := 0
    for _, v := range pt.data {
        sum += v
    }
    return sum
}

// æŒ‡é’ˆæ¥æ”¶è€… - æ¯æ¬¡è°ƒç”¨åªå¤åˆ¶8å­—èŠ‚ï¼ˆæŒ‡é’ˆå¤§å°ï¼‰
func (pt *PerformanceTest) ProcessByPointer() int {
    sum := 0
    for _, v := range pt.data {
        sum += v
    }
    return sum
}

// åŸºå‡†æµ‹è¯•ç¤ºä¾‹
func BenchmarkValueReceiver(b *testing.B) {
    pt := PerformanceTest{name: "test"}
    for i := 0; i < b.N; i++ {
        pt.ProcessByValue()
    }
}

func BenchmarkPointerReceiver(b *testing.B) {
    pt := &PerformanceTest{name: "test"}
    for i := 0; i < b.N; i++ {
        pt.ProcessByPointer()
    }
}
```

**æ¥æ”¶è€…ç±»å‹çš„é™·é˜±**
```go
// é™·é˜±1ï¼šæ··åˆä½¿ç”¨å€¼å’ŒæŒ‡é’ˆæ¥æ”¶è€…
type MixedReceiver struct {
    value int
}

func (m MixedReceiver) ValueMethod() {
    m.value++  // ä¸ä¼šä¿®æ”¹åŸå§‹å€¼
}

func (m *MixedReceiver) PointerMethod() {
    m.value++  // ä¼šä¿®æ”¹åŸå§‹å€¼
}

// é™·é˜±2ï¼šæ¥å£å®ç°çš„å·®å¼‚
type Incrementer interface {
    Increment()
}

type ValueIncrementer struct {
    count int
}

func (vi ValueIncrementer) Increment() {
    vi.count++
}

type PointerIncrementer struct {
    count int
}

func (pi *PointerIncrementer) Increment() {
    pi.count++
}

// ä½¿ç”¨æ—¶çš„åŒºåˆ«
var inc1 Incrementer = ValueIncrementer{}     // OK
var inc2 Incrementer = &ValueIncrementer{}    // OK
var inc3 Incrementer = PointerIncrementer{}   // ç¼–è¯‘é”™è¯¯
var inc4 Incrementer = &PointerIncrementer{}  // OK

// é™·é˜±3ï¼šæ–¹æ³•å€¼å’Œæ–¹æ³•è¡¨è¾¾å¼
m := MixedReceiver{value: 10}

// æ–¹æ³•å€¼
valueMethod := m.ValueMethod      // ç»‘å®šåˆ°mçš„å‰¯æœ¬
pointerMethod := m.PointerMethod  // ç»‘å®šåˆ°&m

// æ–¹æ³•è¡¨è¾¾å¼
ValueMethodExpr := MixedReceiver.ValueMethod
PointerMethodExpr := (*MixedReceiver).PointerMethod

ValueMethodExpr(m)   // ä¼ é€’mçš„å‰¯æœ¬
PointerMethodExpr(&m) // ä¼ é€’mçš„æŒ‡é’ˆ
```

#### 5.2.3 æ–¹æ³•é›†æ·±å…¥ç†è§£

**æ–¹æ³•é›†çš„å®šä¹‰å’Œè§„åˆ™**
```go
type T struct {
    value int
}

// å€¼æ¥æ”¶è€…æ–¹æ³•
func (t T) ValueMethod() {
    fmt.Printf("ValueMethod: %d\n", t.value)
}

// æŒ‡é’ˆæ¥æ”¶è€…æ–¹æ³•
func (t *T) PointerMethod() {
    fmt.Printf("PointerMethod: %d\n", t.value)
}

func (t *T) ModifyMethod() {
    t.value++
}

// æ–¹æ³•é›†è§„åˆ™ï¼š
// Tç±»å‹çš„æ–¹æ³•é›†ï¼šValueMethod
// *Tç±»å‹çš„æ–¹æ³•é›†ï¼šValueMethod, PointerMethod, ModifyMethod

var t T = T{value: 10}
var pt *T = &t

// ç±»å‹Tçš„è°ƒç”¨
t.ValueMethod()    // ç›´æ¥è°ƒç”¨
t.PointerMethod()  // è‡ªåŠ¨å–åœ°å€è°ƒç”¨ (&t).PointerMethod()
t.ModifyMethod()   // è‡ªåŠ¨å–åœ°å€è°ƒç”¨ (&t).ModifyMethod()

// ç±»å‹*Tçš„è°ƒç”¨
pt.ValueMethod()   // è‡ªåŠ¨è§£å¼•ç”¨è°ƒç”¨ (*pt).ValueMethod()
pt.PointerMethod() // ç›´æ¥è°ƒç”¨
pt.ModifyMethod()  // ç›´æ¥è°ƒç”¨
```

**æ¥å£å®ç°å’Œæ–¹æ³•é›†**
```go
// å®šä¹‰æ¥å£
type Reader interface {
    Read() string
}

type Writer interface {
    Write(string)
}

type ReadWriter interface {
    Reader
    Writer
}

// å®ç°ç±»å‹
type File struct {
    content string
}

// å€¼æ¥æ”¶è€…å®ç°Read
func (f File) Read() string {
    return f.content
}

// æŒ‡é’ˆæ¥æ”¶è€…å®ç°Write
func (f *File) Write(content string) {
    f.content = content
}

// æ¥å£å®ç°åˆ†æ
var f File = File{content: "hello"}
var pf *File = &f

// Readeræ¥å£å®ç°
var r1 Reader = f   // OK - Fileå®ç°äº†Readæ–¹æ³•
var r2 Reader = pf  // OK - *Fileä¹Ÿå¯ä»¥è°ƒç”¨Readæ–¹æ³•

// Writeræ¥å£å®ç°
// var w1 Writer = f   // ç¼–è¯‘é”™è¯¯ - Fileæ²¡æœ‰å®ç°Writeæ–¹æ³•
var w2 Writer = pf  // OK - *Fileå®ç°äº†Writeæ–¹æ³•

// ReadWriteræ¥å£å®ç°
// var rw1 ReadWriter = f   // ç¼–è¯‘é”™è¯¯ - Fileæ²¡æœ‰å®ç°Writeæ–¹æ³•
var rw2 ReadWriter = pf  // OK - *Fileå®ç°äº†æ‰€æœ‰æ–¹æ³•
```

**æ–¹æ³•é›†çš„å®é™…åº”ç”¨**
```go
// æ•°æ®åº“è¿æ¥ç¤ºä¾‹
type Database interface {
    Connect() error
    Query(sql string) ([]Row, error)
    Close() error
}

type MySQLDB struct {
    host     string
    port     int
    username string
    password string
    conn     *sql.DB
}

// è¿æ¥æ–¹æ³•éœ€è¦ä¿®æ”¹çŠ¶æ€ï¼Œä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…
func (db *MySQLDB) Connect() error {
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/", 
        db.username, db.password, db.host, db.port)
    
    conn, err := sql.Open("mysql", dsn)
    if err != nil {
        return err
    }
    
    db.conn = conn
    return nil
}

// æŸ¥è¯¢æ–¹æ³•ä¸ä¿®æ”¹çŠ¶æ€ï¼Œä½†ä¸ºäº†ä¸€è‡´æ€§ä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…
func (db *MySQLDB) Query(sqlStr string) ([]Row, error) {
    if db.conn == nil {
        return nil, errors.New("æ•°æ®åº“æœªè¿æ¥")
    }
    
    rows, err := db.conn.Query(sqlStr)
    if err != nil {
        return nil, err
    }
    
    // å¤„ç†ç»“æœ...
    return nil, nil
}

func (db *MySQLDB) Close() error {
    if db.conn != nil {
        return db.conn.Close()
    }
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func useDatabase() {
    // å¿…é¡»ä½¿ç”¨æŒ‡é’ˆç±»å‹æ‰èƒ½å®ç°Databaseæ¥å£
    var db Database = &MySQLDB{
        host:     "localhost",
        port:     3306,
        username: "root",
        password: "password",
    }
    
    db.Connect()
    db.Query("SELECT * FROM users")
    db.Close()
}
```

**æ–¹æ³•é›†çš„å†…å­˜å’Œæ€§èƒ½è€ƒè™‘**
```go
// å¤§ç»“æ„ä½“ç¤ºä¾‹
type LargeStruct struct {
    data [1000]int
    metadata map[string]interface{}
    config   Config
}

type Config struct {
    settings map[string]string
    flags    []bool
}

// å€¼æ¥æ”¶è€… - æ¯æ¬¡è°ƒç”¨å¤åˆ¶æ•´ä¸ªç»“æ„ä½“
func (ls LargeStruct) ProcessByValue() {
    // å¤„ç†é€»è¾‘
    // è¿™é‡Œä¼šå¤åˆ¶çº¦4KBçš„æ•°æ®
}

// æŒ‡é’ˆæ¥æ”¶è€… - åªå¤åˆ¶æŒ‡é’ˆï¼ˆ8å­—èŠ‚ï¼‰
func (ls *LargeStruct) ProcessByPointer() {
    // å¤„ç†é€»è¾‘
    // åªå¤åˆ¶æŒ‡é’ˆï¼Œæ€§èƒ½æ›´å¥½
}

// æ¥å£ä½¿ç”¨æ—¶çš„æ€§èƒ½å·®å¼‚
type Processor interface {
    Process()
}

// å€¼æ¥æ”¶è€…å®ç°
type ValueProcessor LargeStruct
func (vp ValueProcessor) Process() {
    // å®ç°
}

// æŒ‡é’ˆæ¥æ”¶è€…å®ç°
type PointerProcessor LargeStruct
func (pp *PointerProcessor) Process() {
    // å®ç°
}

// æ€§èƒ½æµ‹è¯•
func benchmarkProcessors() {
    large := LargeStruct{/* åˆå§‹åŒ–å¤§é‡æ•°æ® */}
    
    // å€¼ç±»å‹å¤„ç†å™¨ - æ¯æ¬¡æ¥å£è°ƒç”¨éƒ½ä¼šå¤åˆ¶
    var p1 Processor = ValueProcessor(large)
    
    // æŒ‡é’ˆç±»å‹å¤„ç†å™¨ - æ¥å£è°ƒç”¨åªå¤åˆ¶æŒ‡é’ˆ
    var p2 Processor = (*PointerProcessor)(&large)
    
    // p1.Process() æ¯” p2.Process() æ…¢å¾ˆå¤š
}
```

**æ–¹æ³•é›†çš„é«˜çº§ç‰¹æ€§**
```go
// æ–¹æ³•è¡¨è¾¾å¼å’Œæ–¹æ³•å€¼
type Calculator struct {
    result float64
}

func (c *Calculator) Add(x float64) {
    c.result += x
}

func (c Calculator) GetResult() float64 {
    return c.result
}

// æ–¹æ³•è¡¨è¾¾å¼ - å°†æ–¹æ³•è½¬æ¢ä¸ºå‡½æ•°
addMethod := (*Calculator).Add
getMethod := Calculator.GetResult

calc := &Calculator{}
addMethod(calc, 10)  // ç­‰ä»·äº calc.Add(10)
result := getMethod(*calc)  // ç­‰ä»·äº calc.GetResult()

// æ–¹æ³•å€¼ - ç»‘å®šåˆ°ç‰¹å®šå®ä¾‹
calc2 := &Calculator{}
boundAdd := calc2.Add      // ç»‘å®šåˆ°calc2å®ä¾‹
boundGet := calc2.GetResult

boundAdd(20)  // ç­‰ä»·äº calc2.Add(20)
result2 := boundGet()  // ç­‰ä»·äº calc2.GetResult()

// æ–¹æ³•å€¼åœ¨é—­åŒ…ä¸­çš„åº”ç”¨
func createAdder(initial float64) func(float64) {
    calc := &Calculator{result: initial}
    return calc.Add  // è¿”å›ç»‘å®šçš„æ–¹æ³•
}

adder := createAdder(100)
adder(50)  // å†…éƒ¨calculatorçš„resultå˜ä¸º150
```

### 5.3 ç»“æ„ä½“åµŒå…¥

#### 5.3.1 åŒ¿åå­—æ®µåµŒå…¥
```go
type Address struct {
    Street   string
    City     string
    Province string
    ZipCode  string
}

type Person struct {
    Name string
    Age  int
    Address  // åŒ¿ååµŒå…¥
}

p := Person{
    Name: "å¼ ä¸‰",
    Age:  30,
    Address: Address{
        Street:   "ä¸­å±±è·¯123å·",
        City:     "åŒ—äº¬",
        Province: "åŒ—äº¬å¸‚",
        ZipCode:  "100000",
    },
}

// ç›´æ¥è®¿é—®åµŒå…¥å­—æ®µ
fmt.Println("å§“å:", p.Name)
fmt.Println("åŸå¸‚:", p.City)      // ç­‰ä»·äº p.Address.City
fmt.Println("è¡—é“:", p.Street)    // ç­‰ä»·äº p.Address.Street

// ä¹Ÿå¯ä»¥é€šè¿‡å®Œæ•´è·¯å¾„è®¿é—®
fmt.Println("åœ°å€:", p.Address.Street)
```

#### 5.3.2 æ–¹æ³•æå‡
```go
type Engine struct {
    Power int
}

func (e Engine) Start() {
    fmt.Println("å¼•æ“å¯åŠ¨")
}

type Car struct {
    Brand string
    Engine  // åµŒå…¥Engine
}

// Carè‡ªåŠ¨è·å¾—Engineçš„æ–¹æ³•
car := Car{Brand: "ä¸°ç”°", Engine: Engine{Power: 200}}
car.Start()  // è°ƒç”¨åµŒå…¥ç±»å‹çš„æ–¹æ³•
```

#### 5.3.3 å­—æ®µå’Œæ–¹æ³•å†²çª
```go
type A struct {
    Name string
}

func (a A) Method() {
    fmt.Println("Açš„æ–¹æ³•")
}

type B struct {
    Name string
}

func (b B) Method() {
    fmt.Println("Bçš„æ–¹æ³•")
}

type C struct {
    A
    B
}

// ä½¿ç”¨æ—¶éœ€è¦æ˜ç¡®æŒ‡å®š
c := C{}
c.A.Name = "Açš„åå­—"
c.B.Name = "Bçš„åå­—"
c.A.Method()  // è°ƒç”¨Açš„æ–¹æ³•
c.B.Method()  // è°ƒç”¨Bçš„æ–¹æ³•
```

### 5.4 ç»“æ„ä½“æ ‡ç­¾

#### 5.4.1 æ ‡ç­¾å®šä¹‰å’Œä½¿ç”¨
```go
type User struct {
    ID       int    `json:"id" db:"user_id"`
    Name     string `json:"name" db:"username"`
    Email    string `json:"email" db:"email_address"`
    Password string `json:"-" db:"password"`  // jsonå¿½ç•¥
}

// ä½¿ç”¨åå°„è¯»å–æ ‡ç­¾
import "reflect"

func getJSONTag(field reflect.StructField) string {
    return field.Tag.Get("json")
}
```

#### 5.4.2 å¸¸ç”¨æ ‡ç­¾
```go
type Product struct {
    ID          int     `json:"id" gorm:"primaryKey"`
    Name        string  `json:"name" gorm:"size:100;not null"`
    Price       float64 `json:"price" gorm:"type:decimal(10,2)"`
    Description string  `json:"description,omitempty" gorm:"type:text"`
    CreatedAt   time.Time `json:"created_at" gorm:"autoCreateTime"`
}
```

### 5.5 æ„é€ å‡½æ•°æ¨¡å¼

#### 5.5.1 ç®€å•æ„é€ å‡½æ•°
```go
func NewPerson(name string, age int) *Person {
    return &Person{
        Name: name,
        Age:  age,
    }
}
```

#### 5.5.2 é€‰é¡¹æ¨¡å¼
```go
type ServerConfig struct {
    Host    string
    Port    int
    Timeout time.Duration
    TLS     bool
}

type ServerOption func(*ServerConfig)

func WithHost(host string) ServerOption {
    return func(c *ServerConfig) {
        c.Host = host
    }
}

func WithPort(port int) ServerOption {
    return func(c *ServerConfig) {
        c.Port = port
    }
}

func NewServer(opts ...ServerOption) *ServerConfig {
    config := &ServerConfig{
        Host:    "localhost",
        Port:    8080,
        Timeout: 30 * time.Second,
        TLS:     false,
    }
    
    for _, opt := range opts {
        opt(config)
    }
    
    return config
}

// ä½¿ç”¨
server := NewServer(
    WithHost("0.0.0.0"),
    WithPort(9090),
)
```

### 5.6 ç»“æ„ä½“æ¯”è¾ƒå’Œå¤åˆ¶

#### 5.6.1 ç»“æ„ä½“æ¯”è¾ƒ
```go
type Point struct {
    X, Y int
}

p1 := Point{1, 2}
p2 := Point{1, 2}
p3 := Point{2, 3}

fmt.Println(p1 == p2)  // true
fmt.Println(p1 == p3)  // false

// åŒ…å«ä¸å¯æ¯”è¾ƒå­—æ®µçš„ç»“æ„ä½“ä¸èƒ½æ¯”è¾ƒ
type Container struct {
    Data []int  // åˆ‡ç‰‡ä¸å¯æ¯”è¾ƒ
}
// c1 := Container{[]int{1, 2}}
// c2 := Container{[]int{1, 2}}
// fmt.Println(c1 == c2)  // ç¼–è¯‘é”™è¯¯
```

#### 5.6.2 æ·±æ‹·è´å’Œæµ…æ‹·è´
```go
type Person struct {
    Name    string
    Age     int
    Friends []string
}

// æµ…æ‹·è´
p1 := Person{
    Name:    "å¼ ä¸‰",
    Age:     30,
    Friends: []string{"æå››", "ç‹äº”"},
}
p2 := p1  // æµ…æ‹·è´ï¼ŒFriendsåˆ‡ç‰‡å…±äº«

// æ·±æ‹·è´
func (p Person) DeepCopy() Person {
    friends := make([]string, len(p.Friends))
    copy(friends, p.Friends)
    
    return Person{
        Name:    p.Name,
        Age:     p.Age,
        Friends: friends,
    }
}
```

### 5.7 é«˜çº§ç‰¹æ€§å’Œæœ€ä½³å®è·µ

#### 5.7.1 ç»“æ„ä½“çš„å†…å­˜ä¼˜åŒ–

**å­—æ®µå¯¹é½å’Œå†…å­˜å¸ƒå±€**
```go
// å†…å­˜å¯¹é½ç¤ºä¾‹
type BadStruct struct {
    a bool   // 1å­—èŠ‚
    b int64  // 8å­—èŠ‚ï¼Œéœ€è¦7å­—èŠ‚padding
    c bool   // 1å­—èŠ‚  
    d int32  // 4å­—èŠ‚ï¼Œéœ€è¦3å­—èŠ‚padding
}
// æ€»å¤§å°ï¼š24å­—èŠ‚ï¼ˆ1+7+8+1+3+4ï¼‰

type GoodStruct struct {
    b int64  // 8å­—èŠ‚
    d int32  // 4å­—èŠ‚
    a bool   // 1å­—èŠ‚
    c bool   // 1å­—èŠ‚ï¼Œå…±äº«2å­—èŠ‚padding
}
// æ€»å¤§å°ï¼š16å­—èŠ‚ï¼ˆ8+4+1+1+2ï¼‰

// ä½¿ç”¨unsafeåŒ…åˆ†æå†…å­˜å¸ƒå±€
func analyzeMemoryLayout() {
    fmt.Printf("BadStruct size: %d\n", unsafe.Sizeof(BadStruct{}))
    fmt.Printf("GoodStruct size: %d\n", unsafe.Sizeof(GoodStruct{}))
    
    // åˆ†æå­—æ®µåç§»
    bad := BadStruct{}
    fmt.Printf("BadStruct.a offset: %d\n", unsafe.Offsetof(bad.a))
    fmt.Printf("BadStruct.b offset: %d\n", unsafe.Offsetof(bad.b))
    fmt.Printf("BadStruct.c offset: %d\n", unsafe.Offsetof(bad.c))
    fmt.Printf("BadStruct.d offset: %d\n", unsafe.Offsetof(bad.d))
}
```

**é›¶æ‹·è´æŠ€æœ¯**
```go
// ä½¿ç”¨æŒ‡é’ˆé¿å…ä¸å¿…è¦çš„å¤åˆ¶
type LargeData struct {
    payload [1024]byte
    metadata map[string]string
}

// ä¸å¥½çš„åšæ³• - æ¯æ¬¡éƒ½å¤åˆ¶å¤§é‡æ•°æ®
func ProcessDataBad(data LargeData) {
    // å¤„ç†æ•°æ®
}

// å¥½çš„åšæ³• - ä½¿ç”¨æŒ‡é’ˆ
func ProcessDataGood(data *LargeData) {
    // å¤„ç†æ•°æ®
}

// æ¥å£è®¾è®¡ä¸­çš„é›¶æ‹·è´
type DataProcessor interface {
    Process(*LargeData) error
}

// å®ç°æ—¶ä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…
type FastProcessor struct{}

func (fp *FastProcessor) Process(data *LargeData) error {
    // é«˜æ•ˆå¤„ç†ï¼Œæ— éœ€å¤åˆ¶
    return nil
}
```

#### 5.7.2 åå°„å’Œç»“æ„ä½“

**ç»“æ„ä½“åå°„æ“ä½œ**
```go
import (
    "reflect"
    "fmt"
)

type User struct {
    ID       int    `json:"id" validate:"required"`
    Name     string `json:"name" validate:"min=2,max=50"`
    Email    string `json:"email" validate:"email"`
    Password string `json:"-"`
}

// åå°„è·å–ç»“æ„ä½“ä¿¡æ¯
func analyzeStruct(v interface{}) {
    t := reflect.TypeOf(v)
    val := reflect.ValueOf(v)
    
    fmt.Printf("ç±»å‹: %s\n", t.Name())
    fmt.Printf("å­—æ®µæ•°é‡: %d\n", t.NumField())
    
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        value := val.Field(i)
        
        fmt.Printf("å­—æ®µ %d:\n", i)
        fmt.Printf("  åç§°: %s\n", field.Name)
        fmt.Printf("  ç±»å‹: %s\n", field.Type)
        fmt.Printf("  å€¼: %v\n", value.Interface())
        fmt.Printf("  æ ‡ç­¾: %s\n", field.Tag)
        
        // è·å–ç‰¹å®šæ ‡ç­¾
        if jsonTag := field.Tag.Get("json"); jsonTag != "" {
            fmt.Printf("  JSONæ ‡ç­¾: %s\n", jsonTag)
        }
    }
}

// åŠ¨æ€è®¾ç½®å­—æ®µå€¼
func setFieldValue(v interface{}, fieldName string, newValue interface{}) error {
    val := reflect.ValueOf(v)
    if val.Kind() != reflect.Ptr || val.Elem().Kind() != reflect.Struct {
        return errors.New("éœ€è¦ä¼ å…¥ç»“æ„ä½“æŒ‡é’ˆ")
    }
    
    structVal := val.Elem()
    fieldVal := structVal.FieldByName(fieldName)
    
    if !fieldVal.IsValid() {
        return fmt.Errorf("å­—æ®µ %s ä¸å­˜åœ¨", fieldName)
    }
    
    if !fieldVal.CanSet() {
        return fmt.Errorf("å­—æ®µ %s ä¸å¯è®¾ç½®", fieldName)
    }
    
    newVal := reflect.ValueOf(newValue)
    if fieldVal.Type() != newVal.Type() {
        return fmt.Errorf("ç±»å‹ä¸åŒ¹é…")
    }
    
    fieldVal.Set(newVal)
    return nil
}
```

**ç»“æ„ä½“éªŒè¯æ¡†æ¶**
```go
// ç®€å•çš„éªŒè¯æ¡†æ¶å®ç°
type Validator struct{}

func (v *Validator) Validate(s interface{}) []error {
    var errors []error
    val := reflect.ValueOf(s)
    typ := reflect.TypeOf(s)
    
    if val.Kind() == reflect.Ptr {
        val = val.Elem()
        typ = typ.Elem()
    }
    
    for i := 0; i < val.NumField(); i++ {
        field := typ.Field(i)
        fieldVal := val.Field(i)
        
        if validateTag := field.Tag.Get("validate"); validateTag != "" {
            if err := v.validateField(field.Name, fieldVal, validateTag); err != nil {
                errors = append(errors, err)
            }
        }
    }
    
    return errors
}

func (v *Validator) validateField(name string, val reflect.Value, tag string) error {
    switch tag {
    case "required":
        if val.IsZero() {
            return fmt.Errorf("å­—æ®µ %s æ˜¯å¿…éœ€çš„", name)
        }
    case "email":
        if val.Kind() == reflect.String {
            email := val.String()
            if !strings.Contains(email, "@") {
                return fmt.Errorf("å­—æ®µ %s ä¸æ˜¯æœ‰æ•ˆçš„é‚®ç®±", name)
            }
        }
    }
    return nil
}
```

#### 5.7.3 æ€§èƒ½ä¼˜åŒ–æŠ€å·§

**å¯¹è±¡æ± åŒ–**
```go
import "sync"

// ç»“æ„ä½“å¯¹è±¡æ± 
type UserPool struct {
    pool sync.Pool
}

func NewUserPool() *UserPool {
    return &UserPool{
        pool: sync.Pool{
            New: func() interface{} {
                return &User{}
            },
        },
    }
}

func (up *UserPool) Get() *User {
    return up.pool.Get().(*User)
}

func (up *UserPool) Put(user *User) {
    // é‡ç½®å¯¹è±¡çŠ¶æ€
    user.ID = 0
    user.Name = ""
    user.Email = ""
    user.Password = ""
    
    up.pool.Put(user)
}

// ä½¿ç”¨ç¤ºä¾‹
var userPool = NewUserPool()

func processUser(id int, name, email string) {
    user := userPool.Get()
    defer userPool.Put(user)
    
    user.ID = id
    user.Name = name
    user.Email = email
    
    // å¤„ç†ç”¨æˆ·é€»è¾‘
}
```

**å†…å­˜é¢„åˆ†é…**
```go
// é¢„åˆ†é…åˆ‡ç‰‡å®¹é‡
type BatchProcessor struct {
    users []User
}

func NewBatchProcessor(expectedSize int) *BatchProcessor {
    return &BatchProcessor{
        users: make([]User, 0, expectedSize), // é¢„åˆ†é…å®¹é‡
    }
}

func (bp *BatchProcessor) AddUser(user User) {
    bp.users = append(bp.users, user)
}

// é¢„åˆ†é…æ˜ å°„å®¹é‡
type UserCache struct {
    cache map[int]*User
}

func NewUserCache(expectedSize int) *UserCache {
    return &UserCache{
        cache: make(map[int]*User, expectedSize),
    }
}
```

## ğŸ¯ é¢è¯•é‡ç‚¹è§£æ

### æ ¸å¿ƒæ¦‚å¿µç†è§£
1. **ç»“æ„ä½“vsç±»çš„åŒºåˆ«**
   - Goæ²¡æœ‰ç±»çš„æ¦‚å¿µï¼Œä½¿ç”¨ç»“æ„ä½“+æ–¹æ³•å®ç°é¢å‘å¯¹è±¡
   - ç»„åˆä¼˜äºç»§æ‰¿çš„è®¾è®¡å“²å­¦
   - æ¥å£éšå¼å®ç°

2. **å€¼æ¥æ”¶è€…vsæŒ‡é’ˆæ¥æ”¶è€…é€‰æ‹©åŸåˆ™**
   - éœ€è¦ä¿®æ”¹æ¥æ”¶è€…çŠ¶æ€ â†’ æŒ‡é’ˆæ¥æ”¶è€…
   - å¤§ç»“æ„ä½“é¿å…å¤åˆ¶ â†’ æŒ‡é’ˆæ¥æ”¶è€…  
   - å°å€¼ç±»å‹ä¸”ä¸ä¿®æ”¹ â†’ å€¼æ¥æ”¶è€…
   - ä¿æŒä¸€è‡´æ€§åŸåˆ™

3. **æ–¹æ³•é›†è§„åˆ™**
   - Tç±»å‹ï¼šåªæœ‰å€¼æ¥æ”¶è€…æ–¹æ³•
   - *Tç±»å‹ï¼šå€¼æ¥æ”¶è€…+æŒ‡é’ˆæ¥æ”¶è€…æ–¹æ³•
   - æ¥å£å®ç°çš„å½±å“

### å¸¸è§é¢è¯•é™·é˜±
1. **æ¥å£å®ç°é™·é˜±**
   ```go
   type Writer interface {
       Write([]byte) error
   }
   
   type FileWriter struct{}
   func (fw *FileWriter) Write(data []byte) error { return nil }
   
   var w Writer = FileWriter{}  // ç¼–è¯‘é”™è¯¯ï¼
   var w Writer = &FileWriter{} // æ­£ç¡®
   ```

2. **æ–¹æ³•å€¼çš„é™·é˜±**
   ```go
   type Counter struct { count int }
   func (c *Counter) Increment() { c.count++ }
   
   c := &Counter{}
   inc := c.Increment  // ç»‘å®šåˆ°å½“å‰cå®ä¾‹
   c = &Counter{}      // cæŒ‡å‘æ–°å®ä¾‹
   inc()               // ä»ç„¶æ“ä½œåŸæ¥çš„å®ä¾‹ï¼
   ```

3. **åµŒå…¥å­—æ®µçš„é™·é˜±**
   ```go
   type A struct { name string }
   type B struct { A; name string }  // å­—æ®µå†²çª
   
   b := B{}
   b.name = "B"      // è®¾ç½®Bçš„name
   b.A.name = "A"    // è®¾ç½®Açš„name
   ```

### æ€§èƒ½ä¼˜åŒ–è¦ç‚¹
1. **å†…å­˜å¯¹é½ä¼˜åŒ–** - åˆç†æ’åˆ—å­—æ®µé¡ºåº
2. **é¿å…ä¸å¿…è¦çš„å¤åˆ¶** - å¤§ç»“æ„ä½“ä½¿ç”¨æŒ‡é’ˆ
3. **å¯¹è±¡æ± åŒ–** - é¢‘ç¹åˆ›å»ºçš„å¯¹è±¡ä½¿ç”¨sync.Pool
4. **é›¶æ‹·è´è®¾è®¡** - æ¥å£è®¾è®¡è€ƒè™‘æ€§èƒ½

## ğŸš€ å®æˆ˜ç»ƒä¹ 

### ç»ƒä¹ 1ï¼šè®¾è®¡ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„ç¼“å­˜ç³»ç»Ÿ
```go
type Cache struct {
    // å®ç°ä¸€ä¸ªæ”¯æŒè¿‡æœŸæ—¶é—´çš„ç¼“å­˜
    // è¦æ±‚ï¼šçº¿ç¨‹å®‰å…¨ã€æ”¯æŒTTLã€LRUæ·˜æ±°ç­–ç•¥
}
```

### ç»ƒä¹ 2ï¼šå®ç°ä¸€ä¸ªé…ç½®ç®¡ç†å™¨
```go
type ConfigManager struct {
    // æ”¯æŒå¤šç§é…ç½®æºï¼ˆæ–‡ä»¶ã€ç¯å¢ƒå˜é‡ã€å‘½ä»¤è¡Œï¼‰
    // æ”¯æŒé…ç½®çƒ­é‡è½½ã€ç±»å‹å®‰å…¨çš„é…ç½®è®¿é—®
}
```

### ç»ƒä¹ 3ï¼šæ„å»ºä¸€ä¸ªäº‹ä»¶ç³»ç»Ÿ
```go
type EventBus struct {
    // å®ç°å‘å¸ƒè®¢é˜…æ¨¡å¼
    // æ”¯æŒå¼‚æ­¥å¤„ç†ã€é”™è¯¯å¤„ç†ã€ä¼˜é›…å…³é—­
}
```

### ç»ƒä¹ 4ï¼šè®¾è®¡ä¸€ä¸ªæ•°æ®éªŒè¯æ¡†æ¶
```go
type Validator struct {
    // åŸºäºç»“æ„ä½“æ ‡ç­¾çš„éªŒè¯æ¡†æ¶
    // æ”¯æŒè‡ªå®šä¹‰éªŒè¯è§„åˆ™ã€åµŒå¥—éªŒè¯ã€é”™è¯¯èšåˆ
}
```

### ç»ƒä¹ 5ï¼šå®ç°ä¸€ä¸ªORMæ˜ å°„å™¨
```go
type ORMMapper struct {
    // ç»“æ„ä½“åˆ°SQLçš„æ˜ å°„
    // æ”¯æŒå…³è”æŸ¥è¯¢ã€äº‹åŠ¡å¤„ç†ã€è¿æ¥æ± 
}
``` 